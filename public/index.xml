<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://localhost:1313/</link>
    <description>Recent content on </description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 28 Nov 2015 08:36:54 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ISU Events Statistics</title>
      <link>http://localhost:1313/posts/20151128_ISU_stats/</link>
      <pubDate>Sat, 28 Nov 2015 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/posts/20151128_ISU_stats/</guid>
      <description>

&lt;h1 id=&#34;intro:cdcd48f0046b8c293cb9d9854a7b4f96&#34;&gt;Intro&lt;/h1&gt;

&lt;p&gt;Have you ever wondered how many quads where executed in all ISU competitions ever? Or, maybe, which throw in pair skating is most problematic? Perhaps, you want to see statistics for skaters of your nation, or even, you have skills in statistical analysis and want to have nice diagrams on ISU results of overall time?&lt;/p&gt;

&lt;p&gt;Well, I may have a solution for you.&lt;/p&gt;

&lt;p&gt;Since when Judgement System was introduced, it was really nice to have detailed scores and points, which can be easily analyzed by human. There was just one little problem - the scores available to the public are in PDF format, which is printer-friendly, but it’s not parseable by computer programs.&lt;/p&gt;

&lt;p&gt;You can’t just download all PDFs and add them to Excel or R Studio or whatever, to do the analysis. Parseable data was available only to the ISU technicians, and used mainly to calculate standings or internally to analyze rules changes’ effects.&lt;/p&gt;

&lt;p&gt;Now, let me introduce a tool that automatically downloads all PDF scores ever produced in the official ISU events, carefully parses them and generates dataset, available for import into data analysis software.&lt;/p&gt;

&lt;h1 id=&#34;results:cdcd48f0046b8c293cb9d9854a7b4f96&#34;&gt;Results&lt;/h1&gt;

&lt;h2 id=&#34;quads:cdcd48f0046b8c293cb9d9854a7b4f96&#34;&gt;Quads&lt;/h2&gt;

&lt;p&gt;I start with quads, as the most debatable and attracting topic in figure skating since eighties.
Let’s first look on the quads count per year, from &lt;sup&gt;2006&lt;/sup&gt;&amp;frasl;&lt;sub&gt;07&lt;/sub&gt; to &lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;15&lt;/sub&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/quads.png&#34; alt=&#34;Quads&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The trend line is obvious - the number of quads increasing year after year. We see notable decrease of quad attempts in 2009, just before Olympics in Vancouver. But then, ISU changed the rules to give skaters more incentives to try quads in the compettions without worrying of loosing too much on failed jump, so the quads ascending continued.&lt;/p&gt;

&lt;p&gt;Again, we see slight descent of trending line right before Olympics 2014. This difference is interesting in particular, so let’s visualise it.&lt;/p&gt;

&lt;h1 id=&#34;analysys:cdcd48f0046b8c293cb9d9854a7b4f96&#34;&gt;Analysys&lt;/h1&gt;

&lt;p&gt;Now, let’s download all PDF scores ever produced on the official ISU events, and check what we can get out of it.
The data actually not large - scores for all elements in all ISU competitions since 2006, in flatten CSV form (which has lot of redundant data) weights only ~21MB. In compressed form 1.7MB, so it even could be easily sent by e-mail to friend.&lt;/p&gt;

&lt;p&gt;Brief note, flatten CSV format is a Comma Separated Values - is a common format for datasets, because of it’s simplicity and ability to be easily read both by human and machines. You can import it into Excel or use more advanced tools like R Studio, to process data in statistical-friendly R language. We will use latter.&lt;/p&gt;

&lt;p&gt;If you’re unfamiliar with R studio, here is a nice introduction. Also you must have some basic statistics knowledge to get interesting results - if you know the difference between ‘average’ and ‘mean’, you’re fine here. :)&lt;/p&gt;

&lt;p&gt;Let’s load data into R Studio using data.csv() command:
&lt;code&gt;df = read.csv(“~/Downloads/all.csv”)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Variable df now holds our data. Each line represents single executed element and contains all information available - name of event, year, skater name, nationality and gender, name of element, GOE, base value and so on.&lt;/p&gt;

&lt;h1 id=&#34;code:cdcd48f0046b8c293cb9d9854a7b4f96&#34;&gt;Code&lt;/h1&gt;

&lt;p&gt;Code is open-source, licensed under MIT license, so you can freely use it for non-commercial purpose. It written in Go, and binaries are build for Windows, MacOS X, Linux and even FreeBSD platforms. It quite well tested and documented.&lt;/p&gt;

&lt;p&gt;Program itself is a command line based application, which accepts directory or list of PDFs to analyze.&lt;/p&gt;

&lt;p&gt;This program is guaranteed to work with PDF documents generated by ISUCalcFS program, with default settings. It’s well tested on ISU events’ scores, but may fail with scores generated by your local judging system installation.&lt;/p&gt;

&lt;p&gt;You may open an issue (in github.com) and provide me a link your PDF file, so I can take a look. Alternatively, if you’re technical person, you may fix it and send me a pull request. It would be great to keep in touch with developers, passionate in figure skating, anyway ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Explaining Go error handling</title>
      <link>http://localhost:1313/posts/20151127_Test/</link>
      <pubDate>Mon, 02 Nov 2015 08:36:54 -0700</pubDate>
      
      <guid>http://localhost:1313/posts/20151127_Test/</guid>
      <description>&lt;p&gt;I recently translated great article — &lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values&lt;/a&gt; by Rob Pike — and we discussed it in our &lt;a href=&#34;https://golangshow.com/&#34;&gt;podcast Golangshow&lt;/a&gt; (in russian). One thing I was surprised about is that even experienced Go developers sometimes do not understand the core idea of that article.&lt;/p&gt;

&lt;p&gt;Looking back, I remember my first impressions when I read it for the first time. It was similar to &lt;em&gt;“It looks like Pike just adds some complexity to what could’ve been solved gracefully with exceptions”&lt;/em&gt;. I have never been fond of exceptions, but that’s the first thought I remember. The example in the article was clearly asking for comparison with exceptions’ way to deal with errors and it didn’t look like a winner here.&lt;/p&gt;

&lt;p&gt;Still I knew, there must be something more profound in these words — &lt;em&gt;“errors are values”&lt;/em&gt;. After all, I was always comfortable with Go errors handling, so I gave some time to myself to absorb the article.&lt;/p&gt;

&lt;p&gt;And then I got it.&lt;/p&gt;

&lt;p&gt;Go doesn’t want us to treat errors as something different from our main code. Erroneous situation is a first-class citizen in program flow design.&lt;/p&gt;

&lt;blockquote&gt;Errors shouldn’t be hidden or ignored in the same way as you don’t hide or ignore any other code. They are part of your logic and code.&lt;/blockquote&gt;

&lt;p&gt;Just try to imagine your way of thinking when you deal with usual concepts — values, conditions, loops etc., and apply it to the errors. Errors are the same level entities as the rest of your code. You don’t ignore return values of other types for no reason, right? You don’t ask language to bring special way to handle boolean variables, because “if” is boring. You don’t ask yourself “What should I do, if I don’t know what to do with this slice on this abstraction level?”. You just program the logic you need.&lt;/p&gt;

&lt;p&gt;Again, errors are values, and errors’ handling is a normal programming.&lt;/p&gt;

&lt;p&gt;Of course, there are always some patterns to deal with errors (like with any other programming conception), but they emerge naturally and fit perfectly in the existing language capabilities.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Let’s try to illustrate it with an example, close enough to that one in the original article. Say, you have a task — “make repetitive writes with io.Writer and calculate number of bytes written, and stop after 1024-th byte”. You start with straightforward approach:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var count, n int
n = write(“one”)
count += n
if count &amp;gt;= 1024 {
    return
}&lt;/p&gt;

&lt;p&gt;n = write(“two”)
count += n
if count &amp;gt;= 1024 {
    return
}
// etc&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&#34;http://play.golang.org/p/8033Wp9xly&#34;&gt;http://play.golang.org/p/8033Wp9xly&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Of course, you instantly see what’s wrong with this code and, following DRY principle, you decide to deduplicate code, moving repeating parts to separate function or closure:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var count int
cntWrite := func(s string) {
  n := write(s)
  count += n
  if count &amp;gt;= 1024 {
    os.Exit(0)
  }
}&lt;/p&gt;

&lt;p&gt;cntWrite(“one”)
cntWrite(“two”)
cntWrite(“three”)&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&#34;http://play.golang.org/p/Hd12rk6wNk&#34;&gt;http://play.golang.org/p/Hd12rk6wNk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now it’s better, but still not perfect. You still need a closure, which depends on external variable. It also uses os.Exit(), which makes it hardly reusable after first refactoring. We can do better. Let’s see how our thoughts flow — we have a write function, which does something else, except just writing bytes and we need it to be reusable and isolated entity. Let’s refactor our code:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;type cntWriter struct {
    count int
    w io.Writer
}&lt;/p&gt;

&lt;p&gt;func (cw *cntWriter) write(s string) {
    if cw.count &amp;gt;= 1024 {
        return
    }
    n := write(s)
    cw.count += n
}&lt;/p&gt;

&lt;p&gt;func (cw *cntWriter) written() int { return cw.count }&lt;/p&gt;

&lt;p&gt;func main() {
    cw := &amp;amp;cntWriter{}
    cw.write(“one”)
    cw.write(“two”)
    cw.write(“three”)
    fmt.Printf(“Written %d bytes\n”, cw.written())
}&lt;/code&gt;&lt;/pre&gt;
&lt;a href=&#34;http://play.golang.org/p/66Xd1fD8II&#34;&gt;http://play.golang.org/p/66Xd1fD8II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now it looks much better, we can reuse this custom writer in other functions, it’s isolated and easy to test.&lt;/p&gt;

&lt;p&gt;Now, just replace ‘counter’ with ‘error value’ and you’ll get almost the same example as in original article about error handling. But take a note how easy and logical was your flow of thoughts towards this code. You wasn’t distracted by looking for the special counting/passing features of the language. You simply was implementing the logic you need in the best possible way.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This idea is profound enough and could be hard to grasp, especially with the mindset focused on The Only Right Way To Handle Errors™. It definitely takes some time to absorb.&lt;/p&gt;

&lt;p&gt;Of course, it’s debatable, and I can find both a lot of pros and cons for this approach, as well as for others. We’re not in the black&amp;amp;white world, but Go approach to errors is kind of mature and fresh at the same time, it extremely simple and hard to understand at the same time, it requires some rethinking and effort to get the idea. But, what is more important, it works great in practice.&lt;/p&gt;

&lt;p&gt;And once you get it, you stop fight the language. You stop looking for special ways to handle or hide errors. Go makes you respect errors as any other part of your program. You just handle them, without expecting language do the magic for you. In the long run, your code becomes better, even if do not realize it yet.&lt;/p&gt;

&lt;p&gt;Now, come and read this article again —  &lt;a href=&#34;https://blog.golang.org/errors-are-values&#34;&gt;Errors are values&lt;/a&gt; — and try to get the gist of it with this perspective.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>